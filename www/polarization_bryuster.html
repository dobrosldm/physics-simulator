<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
        <!--<meta name="format-detection" content="telephone=no">
        <meta name="msapplication-tap-highlight" content="no">
        <meta name="viewport" content="initial-scale=1, width=device-width, viewport-fit=cover">-->
        <link rel="stylesheet" type="text/css" href="css/index.css">
        <link rel="stylesheet" type="text/css" href="css/geom_optics.css">
        <title>Поляризация. Закон Брюстера</title>

    </head>
    <body>
        <div id="canvas-container">
            <h1>Поляризация. Закон Брюстера</h1>
            <canvas id="canvas" width="400" height="400"></canvas>
        </div>

        <script type="text/javascript" charset="utf-8" src="cordova.js"></script>
        <script type="text/javascript" src="js/touchToCursor.js"></script>

        <script type="text/javascript">

            const RAY_CENTER = { x: 200, y: 200 };

            let cur_angle = Math.PI * 0.25;
            let is_cur_down = false;

            let n1 = 1;
            let n2 = 1.5;

            function onLoad() {
                setupCanvas();
                updateCanvasSize();
                redraw();
            }

            function setupCanvas() {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');

                canvas.onmousedown = canvMouseDown;
                canvas.onmouseup = canvMouseUp;
                canvas.onmousemove = canvMouseMove;
                TouchToCursor(canvas);
            }

            function updateCanvasSize() {
                const canvas = document.getElementById('canvas');

                let size = Math.min(window.innerWidth, window.innerHeight - 60);

                canvas.style.width = size + 'px';
                canvas.style.height = size + 'px';
            }

            function redraw() {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');

                const refrAngle = calcRefrAngle(cur_angle, n1, n2);
				const brAngle = calcBryusterAngle(cur_angle, n1, n2);

				const epsilon = 0.01;

                drawSubstances(ctx);
                drawArrow(ctx, RAY_CENTER, cur_angle, 150, 'in');
				 
				if(Math.abs(cur_angle - brAngle) < epsilon)
				{
                	drawArrow(ctx, RAY_CENTER, -cur_angle, 150, 'out', '#FF00AA', 'polar');
                	drawArrow(ctx, RAY_CENTER, refrAngle, 150, 'out', '#FFAA00','half-polar' );
				} else
				{
					drawArrow(ctx, RAY_CENTER, -cur_angle, 150, 'out', '#FF00AA');
                	drawArrow(ctx, RAY_CENTER, refrAngle, 150, 'out', '#FFAA00');
				}

				drawAngleValue(ctx, RAY_CENTER, 150/3, 0, cur_angle, '#000000');
				if(cur_angle < Math.PI/2)
					drawAngleValue(ctx, RAY_CENTER, 150/3, refrAngle, -cur_angle, '#000000');
				else
					drawAngleValue(ctx, RAY_CENTER, 150/3, -cur_angle, refrAngle, '#000000');
            }

            function drawSubstances(ctx) {
                // substance 1
                ctx.fillStyle = "#FFFFFF";
                ctx.fillRect(0, 0, 400, 400);

                ctx.font = "15px Arial";
                ctx.fillStyle = "#222222";
                ctx.fillText("n1", 10, 190);

                // substance 2
                ctx.fillStyle = "#E5E5FF";
                ctx.fillRect(0, 200, 400, 200);

                ctx.font = "15px Arial";
                ctx.fillStyle = "#222222";
                ctx.fillText("n2", 10, 390);

                // line between
                ctx.beginPath();
                ctx.strokeStyle = "#000000";
                ctx.moveTo(0, 200);
                ctx.lineTo(400, 200);
                ctx.stroke();
                ctx.closePath();

                // dashed line
                ctx.beginPath();
                ctx.strokeStyle = "#000000";
                ctx.setLineDash([5, 3]);
                ctx.moveTo(200, 50);
                ctx.lineTo(200, 350);
                ctx.stroke();
                ctx.closePath();

                ctx.setLineDash([1, 0]);
            }

            function calcSecondPoint(point, angle, length) {
                const width1 = 0;
                const height1 = -length;
                const width2 = Math.cos(angle) * width1 - Math.sin(angle) * height1;
                const height2 = Math.sin(angle) * width1 + Math.cos(angle) * height1;

                return { x: point.x - width2, y: point.y + height2 };
            }

            function drawAngledLine(ctx, point, angle, length, style = "#00AA00") {
                if (isNaN(angle))
                    return;

                const p2 = calcSecondPoint(point, angle, length);

                ctx.beginPath();
                ctx.strokeStyle = style;
                ctx.moveTo(p2.x, p2.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
                ctx.closePath();
            }

			function drawAngledLineWithDashes(ctx, point, angle, length, style = "#00AA00", state = 'unpolar') {
                if (isNaN(angle))
                    return;

				drawAngledLine(ctx, point, angle, length, style);
				
				let margin = length/10;
				let dashLength = length/20;

				if(state != 'polar')
				{
					//draw dashes
					for(let i = 1; i < 9; i++)
					{
						let centerPoint = calcSecondPoint(point, angle, margin*i);
						let p1 = calcSecondPoint(centerPoint, angle + Math.PI/2, dashLength/2);
					
						drawAngledLine(ctx, p1, angle - Math.PI/2, dashLength, '#7A7A7A');
					}
				}

				if(state != 'half-polar')
				{
					for(let i = 1; i < 9; i++)
					{
						let dotPoint = calcSecondPoint(point, angle, margin*i + margin/2);

						ctx.beginPath();
						ctx.strokeStyle = '#7A7A7A';
						ctx.arc(dotPoint.x, dotPoint.y, 1, 0, 2*Math.PI, true);
						ctx.stroke();
						ctx.closePath();
					}					
				}else 
				{
					for(let i = 1; i < 9; i = i + 2)
					{
						let dotPoint = calcSecondPoint(point, angle, margin*i + margin/2);

						ctx.beginPath();
						ctx.strokeStyle = '#7A7A7A';
						ctx.arc(dotPoint.x, dotPoint.y, 1, 0, 2*Math.PI, true);
						ctx.stroke();
						ctx.closePath();
					}		
				}

			}

            function drawArrow(ctx, point, angle, length, where, style = "#00AA00", state) {
                if (isNaN(angle))
                    return;
                
                drawAngledLineWithDashes(ctx, point, angle, length, style, state);
                if (where == 'in') {
                    drawAngledLine(ctx, point, angle + 0.3, 14, style);
                    drawAngledLine(ctx, point, angle - 0.3, 14, style);
                }
                else if (where == 'out') {
                    const p2 = calcSecondPoint(point, angle, length);
                    drawAngledLine(ctx, p2, angle + Math.PI + 0.3, 14, style);
                    drawAngledLine(ctx, p2, angle + Math.PI - 0.3, 14, style);
                }
            }

			function drawAngleValue(ctx, centerPoint, distance, startAngle, endAngle, style = "#00AA00") {
				
				if(startAngle > Math.PI)
					startAngle = -2*Math.PI + startAngle;
				
				if(endAngle > Math.PI)
					endAngle = -2*Math.PI + endAngle;

				const epsilon = 0.01;

				let angle = Math.abs(endAngle - startAngle);

				ctx.beginPath();
				ctx.strokeStyle = style;

				if(Math.abs(angle - Math.PI/2) < epsilon) {
					const p1 = calcSecondPoint(centerPoint, startAngle, distance);
					const p2 = calcSecondPoint(centerPoint, endAngle, distance);
					const p3 = calcSecondPoint(p1, startAngle + Math.PI/2, distance);
					
					ctx.moveTo(p3.x, p3.y);
					ctx.lineTo(p1.x, p1.y);
					ctx.moveTo(p3.x, p3.y);
					ctx.lineTo(p2.x, p2.y);

				} else
					ctx.arc(centerPoint.x, centerPoint.y, distance, -startAngle + 3*Math.PI/2, -endAngle + 3*Math.PI/2, true);
				
				const textPoint = calcSecondPoint(centerPoint, startAngle + angle/2, 9/8*distance);

				ctx.font = "16px Times New Roman";
				const angleInDegrees = Math.round(angle/Math.PI*180);
				ctx.fillText(angleInDegrees, textPoint.x, textPoint.y);

				ctx.stroke();
				ctx.closePath();
			}

            function calcRefrAngle(angle, n_1, n_2) {
                if (angle > Math.PI / 2)
                    [n_1, n_2] = [n_2, n_1];

                let fullReflAngle = Math.asin(n_2 / n_1);
                //console.log("angle: " + angle + ", full refl: " + fullReflAngle);
                if (Math.PI - angle > fullReflAngle)
                    return NaN;

                let result = Math.atan(Math.sin(angle) * n_1 / n_2);
                if (angle < Math.PI / 2)
                    result -= Math.PI;
                else
                    result = Math.PI * 2 - result;
                return result;
            }

			function calcBryusterAngle(angle, n_1, n_2) {
				let result = Math.atan(n_2/n_1);

				if(angle > Math.PI/2)
					result = Math.PI - result;
				return result;
			}

            function calcAngle(mouseX, mouseY) {
                let dx = RAY_CENTER.x - mouseX;
                let dy = RAY_CENTER.y - mouseY;

                if (dx <= 0.001)
                    dx = 0.001;

                if (dy > 0)
                    return Math.atan(dx / dy);
                else if (dy == 0)
                    return Math.PI / 2;
                else
                    return Math.PI / 2 - Math.atan(dy / dx);
            }

            function canvMouseDown(e) {
                is_cur_down = true;
            }

            function canvMouseUp(e) {
                is_cur_down = false;
            }

            function canvMouseMove(e) {
                let canvas = e.target;
                let rect = canvas.getBoundingClientRect();
                let clickX = (e.clientX - rect.left) / (canvas.clientWidth / canvas.width);
                let clickY = (e.clientY - rect.top) / (canvas.clientHeight / canvas.height);

                if (is_cur_down) {
                    cur_angle = calcAngle(clickX, clickY);
                    redraw();
                }
            }

            window.onload = function() {
                onLoad();
            }

            document.addEventListener("deviceready", onLoad, false);

            window.onresize = function(e) {
                updateCanvasSize();
            }
        </script>
    </body>
    </html>
